#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************     TypeDef Section        ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************     Forward Declarations        ********************/

class Program;
class TopDef;
class Arg;
class Block;
class Stmt;
class Item;
class Type;
class Expr;
class AddOp;
class MulOp;
class RelOp;
class CProgram;
class CFnDef;
class CArg;
class SBlock;
class SEmpty;
class SBStmt;
class SDecl;
class SNoInit;
class SInit;
class SAss;
class SIncr;
class SDecr;
class SRet;
class SVRet;
class SCond;
class SCondElse;
class SWhile;
class SExp;
class TInt;
class TStr;
class TBool;
class TVoid;
class EVar;
class ELitInt;
class ELitTrue;
class ELitFalse;
class EApp;
class EString;
class Neg;
class Not;
class EMul;
class EAdd;
class ERel;
class EAnd;
class EOr;
class OPlus;
class OMinus;
class OTimes;
class ODiv;
class OMod;
class OLTH;
class OLE;
class OGTH;
class OGE;
class OEQU;
class ONE;
class ListTopDef;
class ListArg;
class ListStmt;
class ListItem;
class ListExpr;


/********************     Visitor Interfaces        ********************/
class Visitor
{
public:
    virtual ~Visitor() {}
    virtual void visitProgram(Program *p) = 0;
    virtual void visitTopDef(TopDef *p) = 0;
    virtual void visitArg(Arg *p) = 0;
    virtual void visitBlock(Block *p) = 0;
    virtual void visitStmt(Stmt *p) = 0;
    virtual void visitItem(Item *p) = 0;
    virtual void visitType(Type *p) = 0;
    virtual void visitExpr(Expr *p) = 0;
    virtual void visitAddOp(AddOp *p) = 0;
    virtual void visitMulOp(MulOp *p) = 0;
    virtual void visitRelOp(RelOp *p) = 0;
    virtual void visitCProgram(CProgram *p) = 0;
    virtual void visitCFnDef(CFnDef *p) = 0;
    virtual void visitCArg(CArg *p) = 0;
    virtual void visitSBlock(SBlock *p) = 0;
    virtual void visitSEmpty(SEmpty *p) = 0;
    virtual void visitSBStmt(SBStmt *p) = 0;
    virtual void visitSDecl(SDecl *p) = 0;
    virtual void visitSNoInit(SNoInit *p) = 0;
    virtual void visitSInit(SInit *p) = 0;
    virtual void visitSAss(SAss *p) = 0;
    virtual void visitSIncr(SIncr *p) = 0;
    virtual void visitSDecr(SDecr *p) = 0;
    virtual void visitSRet(SRet *p) = 0;
    virtual void visitSVRet(SVRet *p) = 0;
    virtual void visitSCond(SCond *p) = 0;
    virtual void visitSCondElse(SCondElse *p) = 0;
    virtual void visitSWhile(SWhile *p) = 0;
    virtual void visitSExp(SExp *p) = 0;
    virtual void visitTInt(TInt *p) = 0;
    virtual void visitTStr(TStr *p) = 0;
    virtual void visitTBool(TBool *p) = 0;
    virtual void visitTVoid(TVoid *p) = 0;
    virtual void visitEVar(EVar *p) = 0;
    virtual void visitELitInt(ELitInt *p) = 0;
    virtual void visitELitTrue(ELitTrue *p) = 0;
    virtual void visitELitFalse(ELitFalse *p) = 0;
    virtual void visitEApp(EApp *p) = 0;
    virtual void visitEString(EString *p) = 0;
    virtual void visitNeg(Neg *p) = 0;
    virtual void visitNot(Not *p) = 0;
    virtual void visitEMul(EMul *p) = 0;
    virtual void visitEAdd(EAdd *p) = 0;
    virtual void visitERel(ERel *p) = 0;
    virtual void visitEAnd(EAnd *p) = 0;
    virtual void visitEOr(EOr *p) = 0;
    virtual void visitOPlus(OPlus *p) = 0;
    virtual void visitOMinus(OMinus *p) = 0;
    virtual void visitOTimes(OTimes *p) = 0;
    virtual void visitODiv(ODiv *p) = 0;
    virtual void visitOMod(OMod *p) = 0;
    virtual void visitOLTH(OLTH *p) = 0;
    virtual void visitOLE(OLE *p) = 0;
    virtual void visitOGTH(OGTH *p) = 0;
    virtual void visitOGE(OGE *p) = 0;
    virtual void visitOEQU(OEQU *p) = 0;
    virtual void visitONE(ONE *p) = 0;
    virtual void visitListTopDef(ListTopDef *p) = 0;
    virtual void visitListArg(ListArg *p) = 0;
    virtual void visitListStmt(ListStmt *p) = 0;
    virtual void visitListItem(ListItem *p) = 0;
    virtual void visitListExpr(ListExpr *p) = 0;


    virtual void visitInteger(Integer x) = 0;
    virtual void visitChar(Char x) = 0;
    virtual void visitDouble(Double x) = 0;
    virtual void visitString(String x) = 0;
    virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
    virtual ~Visitable() {}
    virtual void accept(Visitor *v) = 0;
};


/********************     Abstract Syntax Classes        ********************/

class Program : public Visitable
{
public:
    virtual Program *clone() const = 0;
    int line_number;
};

class TopDef : public Visitable
{
public:
    virtual TopDef *clone() const = 0;
    int line_number;
};

class Arg : public Visitable
{
public:
    virtual Arg *clone() const = 0;
    int line_number;
};

class Block : public Visitable
{
public:
    virtual Block *clone() const = 0;
    int line_number;
};

class Stmt : public Visitable
{
public:
    virtual Stmt *clone() const = 0;
    int line_number;
};

class Item : public Visitable
{
public:
    virtual Item *clone() const = 0;
    int line_number;
};

class Type : public Visitable
{
public:
    virtual Type *clone() const = 0;
    int line_number;
};

class Expr : public Visitable
{
public:
    virtual Expr *clone() const = 0;
    int line_number;
};

class AddOp : public Visitable
{
public:
    virtual AddOp *clone() const = 0;
    int line_number;
};

class MulOp : public Visitable
{
public:
    virtual MulOp *clone() const = 0;
    int line_number;
};

class RelOp : public Visitable
{
public:
    virtual RelOp *clone() const = 0;
    int line_number;
};



class CProgram : public Program
{
public:
    ListTopDef *listtopdef_;

    CProgram(const CProgram &);
    CProgram &operator=(const CProgram &);
    CProgram(ListTopDef *p1);
    ~CProgram();
    virtual void accept(Visitor *v);
    virtual CProgram *clone() const;
    void swap(CProgram &);
};

class CFnDef : public TopDef
{
public:
    Type *type_;
    Ident ident_;
    ListArg *listarg_;
    Block *block_;

    CFnDef(const CFnDef &);
    CFnDef &operator=(const CFnDef &);
    CFnDef(Type *p1, Ident p2, ListArg *p3, Block *p4);
    ~CFnDef();
    virtual void accept(Visitor *v);
    virtual CFnDef *clone() const;
    void swap(CFnDef &);
};

class CArg : public Arg
{
public:
    Type *type_;
    Ident ident_;

    CArg(const CArg &);
    CArg &operator=(const CArg &);
    CArg(Type *p1, Ident p2);
    ~CArg();
    virtual void accept(Visitor *v);
    virtual CArg *clone() const;
    void swap(CArg &);
};

class SBlock : public Block
{
public:
    ListStmt *liststmt_;

    SBlock(const SBlock &);
    SBlock &operator=(const SBlock &);
    SBlock(ListStmt *p1);
    ~SBlock();
    virtual void accept(Visitor *v);
    virtual SBlock *clone() const;
    void swap(SBlock &);
};

class SEmpty : public Stmt
{
public:

    SEmpty(const SEmpty &);
    SEmpty &operator=(const SEmpty &);
    SEmpty();
    ~SEmpty();
    virtual void accept(Visitor *v);
    virtual SEmpty *clone() const;
    void swap(SEmpty &);
};

class SBStmt : public Stmt
{
public:
    Block *block_;

    SBStmt(const SBStmt &);
    SBStmt &operator=(const SBStmt &);
    SBStmt(Block *p1);
    ~SBStmt();
    virtual void accept(Visitor *v);
    virtual SBStmt *clone() const;
    void swap(SBStmt &);
};

class SDecl : public Stmt
{
public:
    Type *type_;
    ListItem *listitem_;

    SDecl(const SDecl &);
    SDecl &operator=(const SDecl &);
    SDecl(Type *p1, ListItem *p2);
    ~SDecl();
    virtual void accept(Visitor *v);
    virtual SDecl *clone() const;
    void swap(SDecl &);
};

class SAss : public Stmt
{
public:
    Ident ident_;
    Expr *expr_;

    SAss(const SAss &);
    SAss &operator=(const SAss &);
    SAss(Ident p1, Expr *p2);
    ~SAss();
    virtual void accept(Visitor *v);
    virtual SAss *clone() const;
    void swap(SAss &);
};

class SIncr : public Stmt
{
public:
    Ident ident_;

    SIncr(const SIncr &);
    SIncr &operator=(const SIncr &);
    SIncr(Ident p1);
    ~SIncr();
    virtual void accept(Visitor *v);
    virtual SIncr *clone() const;
    void swap(SIncr &);
};

class SDecr : public Stmt
{
public:
    Ident ident_;

    SDecr(const SDecr &);
    SDecr &operator=(const SDecr &);
    SDecr(Ident p1);
    ~SDecr();
    virtual void accept(Visitor *v);
    virtual SDecr *clone() const;
    void swap(SDecr &);
};

class SRet : public Stmt
{
public:
    Expr *expr_;

    SRet(const SRet &);
    SRet &operator=(const SRet &);
    SRet(Expr *p1);
    ~SRet();
    virtual void accept(Visitor *v);
    virtual SRet *clone() const;
    void swap(SRet &);
};

class SVRet : public Stmt
{
public:

    SVRet(const SVRet &);
    SVRet &operator=(const SVRet &);
    SVRet();
    ~SVRet();
    virtual void accept(Visitor *v);
    virtual SVRet *clone() const;
    void swap(SVRet &);
};

class SCond : public Stmt
{
public:
    Expr *expr_;
    Stmt *stmt_;

    SCond(const SCond &);
    SCond &operator=(const SCond &);
    SCond(Expr *p1, Stmt *p2);
    ~SCond();
    virtual void accept(Visitor *v);
    virtual SCond *clone() const;
    void swap(SCond &);
};

class SCondElse : public Stmt
{
public:
    Expr *expr_;
    Stmt *stmt_1;
    Stmt *stmt_2;

    SCondElse(const SCondElse &);
    SCondElse &operator=(const SCondElse &);
    SCondElse(Expr *p1, Stmt *p2, Stmt *p3);
    ~SCondElse();
    virtual void accept(Visitor *v);
    virtual SCondElse *clone() const;
    void swap(SCondElse &);
};

class SWhile : public Stmt
{
public:
    Expr *expr_;
    Stmt *stmt_;

    SWhile(const SWhile &);
    SWhile &operator=(const SWhile &);
    SWhile(Expr *p1, Stmt *p2);
    ~SWhile();
    virtual void accept(Visitor *v);
    virtual SWhile *clone() const;
    void swap(SWhile &);
};

class SExp : public Stmt
{
public:
    Expr *expr_;

    SExp(const SExp &);
    SExp &operator=(const SExp &);
    SExp(Expr *p1);
    ~SExp();
    virtual void accept(Visitor *v);
    virtual SExp *clone() const;
    void swap(SExp &);
};

class SNoInit : public Item
{
public:
    Ident ident_;

    SNoInit(const SNoInit &);
    SNoInit &operator=(const SNoInit &);
    SNoInit(Ident p1);
    ~SNoInit();
    virtual void accept(Visitor *v);
    virtual SNoInit *clone() const;
    void swap(SNoInit &);
};

class SInit : public Item
{
public:
    Ident ident_;
    Expr *expr_;

    SInit(const SInit &);
    SInit &operator=(const SInit &);
    SInit(Ident p1, Expr *p2);
    ~SInit();
    virtual void accept(Visitor *v);
    virtual SInit *clone() const;
    void swap(SInit &);
};

class TInt : public Type
{
public:

    TInt(const TInt &);
    TInt &operator=(const TInt &);
    TInt();
    ~TInt();
    virtual void accept(Visitor *v);
    virtual TInt *clone() const;
    void swap(TInt &);
};

class TStr : public Type
{
public:

    TStr(const TStr &);
    TStr &operator=(const TStr &);
    TStr();
    ~TStr();
    virtual void accept(Visitor *v);
    virtual TStr *clone() const;
    void swap(TStr &);
};

class TBool : public Type
{
public:

    TBool(const TBool &);
    TBool &operator=(const TBool &);
    TBool();
    ~TBool();
    virtual void accept(Visitor *v);
    virtual TBool *clone() const;
    void swap(TBool &);
};

class TVoid : public Type
{
public:

    TVoid(const TVoid &);
    TVoid &operator=(const TVoid &);
    TVoid();
    ~TVoid();
    virtual void accept(Visitor *v);
    virtual TVoid *clone() const;
    void swap(TVoid &);
};

class EVar : public Expr
{
public:
    Ident ident_;

    EVar(const EVar &);
    EVar &operator=(const EVar &);
    EVar(Ident p1);
    ~EVar();
    virtual void accept(Visitor *v);
    virtual EVar *clone() const;
    void swap(EVar &);
};

class ELitInt : public Expr
{
public:
    Integer integer_;

    ELitInt(const ELitInt &);
    ELitInt &operator=(const ELitInt &);
    ELitInt(Integer p1);
    ~ELitInt();
    virtual void accept(Visitor *v);
    virtual ELitInt *clone() const;
    void swap(ELitInt &);
};

class ELitTrue : public Expr
{
public:

    ELitTrue(const ELitTrue &);
    ELitTrue &operator=(const ELitTrue &);
    ELitTrue();
    ~ELitTrue();
    virtual void accept(Visitor *v);
    virtual ELitTrue *clone() const;
    void swap(ELitTrue &);
};

class ELitFalse : public Expr
{
public:

    ELitFalse(const ELitFalse &);
    ELitFalse &operator=(const ELitFalse &);
    ELitFalse();
    ~ELitFalse();
    virtual void accept(Visitor *v);
    virtual ELitFalse *clone() const;
    void swap(ELitFalse &);
};

class EApp : public Expr
{
public:
    Ident ident_;
    ListExpr *listexpr_;

    EApp(const EApp &);
    EApp &operator=(const EApp &);
    EApp(Ident p1, ListExpr *p2);
    ~EApp();
    virtual void accept(Visitor *v);
    virtual EApp *clone() const;
    void swap(EApp &);
};

class EString : public Expr
{
public:
    String string_;

    EString(const EString &);
    EString &operator=(const EString &);
    EString(String p1);
    ~EString();
    virtual void accept(Visitor *v);
    virtual EString *clone() const;
    void swap(EString &);
};

class Neg : public Expr
{
public:
    Expr *expr_;

    Neg(const Neg &);
    Neg &operator=(const Neg &);
    Neg(Expr *p1);
    ~Neg();
    virtual void accept(Visitor *v);
    virtual Neg *clone() const;
    void swap(Neg &);
};

class Not : public Expr
{
public:
    Expr *expr_;

    Not(const Not &);
    Not &operator=(const Not &);
    Not(Expr *p1);
    ~Not();
    virtual void accept(Visitor *v);
    virtual Not *clone() const;
    void swap(Not &);
};

class EMul : public Expr
{
public:
    Expr *expr_1;
    MulOp *mulop_;
    Expr *expr_2;

    EMul(const EMul &);
    EMul &operator=(const EMul &);
    EMul(Expr *p1, MulOp *p2, Expr *p3);
    ~EMul();
    virtual void accept(Visitor *v);
    virtual EMul *clone() const;
    void swap(EMul &);
};

class EAdd : public Expr
{
public:
    Expr *expr_1;
    AddOp *addop_;
    Expr *expr_2;

    EAdd(const EAdd &);
    EAdd &operator=(const EAdd &);
    EAdd(Expr *p1, AddOp *p2, Expr *p3);
    ~EAdd();
    virtual void accept(Visitor *v);
    virtual EAdd *clone() const;
    void swap(EAdd &);
};

class ERel : public Expr
{
public:
    Expr *expr_1;
    RelOp *relop_;
    Expr *expr_2;

    ERel(const ERel &);
    ERel &operator=(const ERel &);
    ERel(Expr *p1, RelOp *p2, Expr *p3);
    ~ERel();
    virtual void accept(Visitor *v);
    virtual ERel *clone() const;
    void swap(ERel &);
};

class EAnd : public Expr
{
public:
    Expr *expr_1;
    Expr *expr_2;

    EAnd(const EAnd &);
    EAnd &operator=(const EAnd &);
    EAnd(Expr *p1, Expr *p2);
    ~EAnd();
    virtual void accept(Visitor *v);
    virtual EAnd *clone() const;
    void swap(EAnd &);
};

class EOr : public Expr
{
public:
    Expr *expr_1;
    Expr *expr_2;

    EOr(const EOr &);
    EOr &operator=(const EOr &);
    EOr(Expr *p1, Expr *p2);
    ~EOr();
    virtual void accept(Visitor *v);
    virtual EOr *clone() const;
    void swap(EOr &);
};

class OPlus : public AddOp
{
public:

    OPlus(const OPlus &);
    OPlus &operator=(const OPlus &);
    OPlus();
    ~OPlus();
    virtual void accept(Visitor *v);
    virtual OPlus *clone() const;
    void swap(OPlus &);
};

class OMinus : public AddOp
{
public:

    OMinus(const OMinus &);
    OMinus &operator=(const OMinus &);
    OMinus();
    ~OMinus();
    virtual void accept(Visitor *v);
    virtual OMinus *clone() const;
    void swap(OMinus &);
};

class OTimes : public MulOp
{
public:

    OTimes(const OTimes &);
    OTimes &operator=(const OTimes &);
    OTimes();
    ~OTimes();
    virtual void accept(Visitor *v);
    virtual OTimes *clone() const;
    void swap(OTimes &);
};

class ODiv : public MulOp
{
public:

    ODiv(const ODiv &);
    ODiv &operator=(const ODiv &);
    ODiv();
    ~ODiv();
    virtual void accept(Visitor *v);
    virtual ODiv *clone() const;
    void swap(ODiv &);
};

class OMod : public MulOp
{
public:

    OMod(const OMod &);
    OMod &operator=(const OMod &);
    OMod();
    ~OMod();
    virtual void accept(Visitor *v);
    virtual OMod *clone() const;
    void swap(OMod &);
};

class OLTH : public RelOp
{
public:

    OLTH(const OLTH &);
    OLTH &operator=(const OLTH &);
    OLTH();
    ~OLTH();
    virtual void accept(Visitor *v);
    virtual OLTH *clone() const;
    void swap(OLTH &);
};

class OLE : public RelOp
{
public:

    OLE(const OLE &);
    OLE &operator=(const OLE &);
    OLE();
    ~OLE();
    virtual void accept(Visitor *v);
    virtual OLE *clone() const;
    void swap(OLE &);
};

class OGTH : public RelOp
{
public:

    OGTH(const OGTH &);
    OGTH &operator=(const OGTH &);
    OGTH();
    ~OGTH();
    virtual void accept(Visitor *v);
    virtual OGTH *clone() const;
    void swap(OGTH &);
};

class OGE : public RelOp
{
public:

    OGE(const OGE &);
    OGE &operator=(const OGE &);
    OGE();
    ~OGE();
    virtual void accept(Visitor *v);
    virtual OGE *clone() const;
    void swap(OGE &);
};

class OEQU : public RelOp
{
public:

    OEQU(const OEQU &);
    OEQU &operator=(const OEQU &);
    OEQU();
    ~OEQU();
    virtual void accept(Visitor *v);
    virtual OEQU *clone() const;
    void swap(OEQU &);
};

class ONE : public RelOp
{
public:

    ONE(const ONE &);
    ONE &operator=(const ONE &);
    ONE();
    ~ONE();
    virtual void accept(Visitor *v);
    virtual ONE *clone() const;
    void swap(ONE &);
};



class ListTopDef : public Visitable
{
    std::vector<TopDef*> listtopdef_;
public:
    virtual void accept(Visitor *v);
    virtual ListTopDef *clone() const;
    
    std::vector<TopDef*>::iterator begin()
    {
        return listtopdef_.begin();
    }

    std::vector<TopDef*>::iterator end()
    {
        return listtopdef_.end();
    }

    void push_back(TopDef* x)
    {
        listtopdef_.push_back(x);
    }
};

class ListArg : public Visitable
{
    std::vector<Arg*> listarg_;
public:
    virtual void accept(Visitor *v);
    virtual ListArg *clone() const;
   
    std::vector<Arg*>::iterator begin()
    {
        return listarg_.begin();
    }

    std::vector<Arg*>::iterator end()
    {
        return listarg_.end();
    }

    void push_back(Arg* x)
    {
        listarg_.push_back(x);
    }
};

class ListStmt : public Visitable
{
    std::vector<Stmt*> liststmt_;
public:
    virtual void accept(Visitor *v);
    virtual ListStmt *clone() const;

    std::vector<Stmt*>::iterator begin()
    {
        return liststmt_.begin();
    }

    std::vector<Stmt*>::iterator end()
    {
        return liststmt_.end();
    }

    void push_back(Stmt* x)
    {
        liststmt_.push_back(x);
    }
};

class ListItem : public Visitable
{
    std::vector<Item*> listitem_;
public:
    virtual void accept(Visitor *v);
    virtual ListItem *clone() const;
    
    std::vector<Item*>::iterator begin()
    {
        return listitem_.begin();
    }

    std::vector<Item*>::iterator end()
    {
        return listitem_.end();
    }
    
    void push_back(Item* x)
    {
        listitem_.push_back(x);
    }
};

class ListExpr : public Visitable
{
    std::vector<Expr*> listexpr_;
public:
    virtual void accept(Visitor *v);
    virtual ListExpr *clone() const;
    
    std::vector<Expr*>::iterator begin()
    {
        return listexpr_.begin();
    }

    std::vector<Expr*>::iterator end()
    {
        return listexpr_.end();
    }

    void push_back(Expr* x)
    {
        listexpr_.push_back(x);
    }
};



#endif
