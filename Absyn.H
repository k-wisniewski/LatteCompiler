#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class TopDef;
class Arg;
class Block;
class Stmt;
class Item;
class Type;
class Expr;
class AddOp;
class MulOp;
class RelOp;
class TProgram;
class TFnDef;
class TArg;
class TBlock;
class Empty;
class BStmt;
class Decl;
class NoInit;
class Init;
class Ass;
class Incr;
class Decr;
class Ret;
class VRet;
class Cond;
class CondElse;
class While;
class SExp;
class TInt;
class TStr;
class TBool;
class TVoid;
class EVar;
class ELitInt;
class ELitTrue;
class ELitFalse;
class EApp;
class EString;
class Neg;
class Not;
class EMul;
class EAdd;
class ERel;
class EAnd;
class EOr;
class OpPlus;
class OpMinus;
class OpTimes;
class OpDiv;
class OpMod;
class OpLTH;
class OpLE;
class OpGTH;
class OpGE;
class OpEQU;
class OpNE;
class ListTopDef;
class ListArg;
class ListStmt;
class ListItem;
class ListExpr;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitTopDef(TopDef *p) = 0;
  virtual void visitArg(Arg *p) = 0;
  virtual void visitBlock(Block *p) = 0;
  virtual void visitStmt(Stmt *p) = 0;
  virtual void visitItem(Item *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitAddOp(AddOp *p) = 0;
  virtual void visitMulOp(MulOp *p) = 0;
  virtual void visitRelOp(RelOp *p) = 0;
  virtual void visitTProgram(TProgram *p) = 0;
  virtual void visitTFnDef(TFnDef *p) = 0;
  virtual void visitTArg(TArg *p) = 0;
  virtual void visitTBlock(TBlock *p) = 0;
  virtual void visitEmpty(Empty *p) = 0;
  virtual void visitBStmt(BStmt *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitNoInit(NoInit *p) = 0;
  virtual void visitInit(Init *p) = 0;
  virtual void visitAss(Ass *p) = 0;
  virtual void visitIncr(Incr *p) = 0;
  virtual void visitDecr(Decr *p) = 0;
  virtual void visitRet(Ret *p) = 0;
  virtual void visitVRet(VRet *p) = 0;
  virtual void visitCond(Cond *p) = 0;
  virtual void visitCondElse(CondElse *p) = 0;
  virtual void visitWhile(While *p) = 0;
  virtual void visitSExp(SExp *p) = 0;
  virtual void visitTInt(TInt *p) = 0;
  virtual void visitTStr(TStr *p) = 0;
  virtual void visitTBool(TBool *p) = 0;
  virtual void visitTVoid(TVoid *p) = 0;
  virtual void visitEVar(EVar *p) = 0;
  virtual void visitELitInt(ELitInt *p) = 0;
  virtual void visitELitTrue(ELitTrue *p) = 0;
  virtual void visitELitFalse(ELitFalse *p) = 0;
  virtual void visitEApp(EApp *p) = 0;
  virtual void visitEString(EString *p) = 0;
  virtual void visitNeg(Neg *p) = 0;
  virtual void visitNot(Not *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitERel(ERel *p) = 0;
  virtual void visitEAnd(EAnd *p) = 0;
  virtual void visitEOr(EOr *p) = 0;
  virtual void visitOpPlus(OpPlus *p) = 0;
  virtual void visitOpMinus(OpMinus *p) = 0;
  virtual void visitOpTimes(OpTimes *p) = 0;
  virtual void visitOpDiv(OpDiv *p) = 0;
  virtual void visitOpMod(OpMod *p) = 0;
  virtual void visitOpLTH(OpLTH *p) = 0;
  virtual void visitOpLE(OpLE *p) = 0;
  virtual void visitOpGTH(OpGTH *p) = 0;
  virtual void visitOpGE(OpGE *p) = 0;
  virtual void visitOpEQU(OpEQU *p) = 0;
  virtual void visitOpNE(OpNE *p) = 0;
  virtual void visitListTopDef(ListTopDef *p) = 0;
  virtual void visitListArg(ListArg *p) = 0;
  virtual void visitListStmt(ListStmt *p) = 0;
  virtual void visitListItem(ListItem *p) = 0;
  virtual void visitListExpr(ListExpr *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;
  int line_number;
};

class TopDef : public Visitable
{
public:
  virtual TopDef *clone() const = 0;
  int line_number;
};

class Arg : public Visitable
{
public:
  virtual Arg *clone() const = 0;
  int line_number;
};

class Block : public Visitable
{
public:
  virtual Block *clone() const = 0;
  int line_number;
};

class Stmt : public Visitable
{
public:
  virtual Stmt *clone() const = 0;
  int line_number;
};

class Item : public Visitable
{
public:
  virtual Item *clone() const = 0;
  int line_number;
};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;
  int line_number;
};

class Expr : public Visitable
{
public:
  virtual Expr *clone() const = 0;
  int line_number;
};

class AddOp : public Visitable
{
public:
  virtual AddOp *clone() const = 0;
  int line_number;
};

class MulOp : public Visitable
{
public:
  virtual MulOp *clone() const = 0;
  int line_number;
};

class RelOp : public Visitable
{
public:
  virtual RelOp *clone() const = 0;
  int line_number;
};



class TProgram : public Program
{
public:
  ListTopDef *listtopdef_;

  TProgram(const TProgram &);
  TProgram &operator=(const TProgram &);
  TProgram(ListTopDef *p1);
  ~TProgram();
  virtual void accept(Visitor *v);
  virtual TProgram *clone() const;
  void swap(TProgram &);
};

class TFnDef : public TopDef
{
public:
  Type *type_;
  Ident ident_;
  ListArg *listarg_;
  Block *block_;

  TFnDef(const TFnDef &);
  TFnDef &operator=(const TFnDef &);
  TFnDef(Type *p1, Ident p2, ListArg *p3, Block *p4);
  ~TFnDef();
  virtual void accept(Visitor *v);
  virtual TFnDef *clone() const;
  void swap(TFnDef &);
};

class TArg : public Arg
{
public:
  Type *type_;
  Ident ident_;

  TArg(const TArg &);
  TArg &operator=(const TArg &);
  TArg(Type *p1, Ident p2);
  ~TArg();
  virtual void accept(Visitor *v);
  virtual TArg *clone() const;
  void swap(TArg &);
};

class TBlock : public Block
{
public:
  ListStmt *liststmt_;

  TBlock(const TBlock &);
  TBlock &operator=(const TBlock &);
  TBlock(ListStmt *p1);
  ~TBlock();
  virtual void accept(Visitor *v);
  virtual TBlock *clone() const;
  void swap(TBlock &);
};

class Empty : public Stmt
{
public:

  Empty(const Empty &);
  Empty &operator=(const Empty &);
  Empty();
  ~Empty();
  virtual void accept(Visitor *v);
  virtual Empty *clone() const;
  void swap(Empty &);
};

class BStmt : public Stmt
{
public:
  Block *block_;

  BStmt(const BStmt &);
  BStmt &operator=(const BStmt &);
  BStmt(Block *p1);
  ~BStmt();
  virtual void accept(Visitor *v);
  virtual BStmt *clone() const;
  void swap(BStmt &);
};

class Decl : public Stmt
{
public:
  Type *type_;
  ListItem *listitem_;

  Decl(const Decl &);
  Decl &operator=(const Decl &);
  Decl(Type *p1, ListItem *p2);
  ~Decl();
  virtual void accept(Visitor *v);
  virtual Decl *clone() const;
  void swap(Decl &);
};

class Ass : public Stmt
{
public:
  Ident ident_;
  Expr *expr_;

  Ass(const Ass &);
  Ass &operator=(const Ass &);
  Ass(Ident p1, Expr *p2);
  ~Ass();
  virtual void accept(Visitor *v);
  virtual Ass *clone() const;
  void swap(Ass &);
};

class Incr : public Stmt
{
public:
  Ident ident_;

  Incr(const Incr &);
  Incr &operator=(const Incr &);
  Incr(Ident p1);
  ~Incr();
  virtual void accept(Visitor *v);
  virtual Incr *clone() const;
  void swap(Incr &);
};

class Decr : public Stmt
{
public:
  Ident ident_;

  Decr(const Decr &);
  Decr &operator=(const Decr &);
  Decr(Ident p1);
  ~Decr();
  virtual void accept(Visitor *v);
  virtual Decr *clone() const;
  void swap(Decr &);
};

class Ret : public Stmt
{
public:
  Expr *expr_;

  Ret(const Ret &);
  Ret &operator=(const Ret &);
  Ret(Expr *p1);
  ~Ret();
  virtual void accept(Visitor *v);
  virtual Ret *clone() const;
  void swap(Ret &);
};

class VRet : public Stmt
{
public:

  VRet(const VRet &);
  VRet &operator=(const VRet &);
  VRet();
  ~VRet();
  virtual void accept(Visitor *v);
  virtual VRet *clone() const;
  void swap(VRet &);
};

class Cond : public Stmt
{
public:
  Expr *expr_;
  Stmt *stmt_;

  Cond(const Cond &);
  Cond &operator=(const Cond &);
  Cond(Expr *p1, Stmt *p2);
  ~Cond();
  virtual void accept(Visitor *v);
  virtual Cond *clone() const;
  void swap(Cond &);
};

class CondElse : public Stmt
{
public:
  Expr *expr_;
  Stmt *stmt_1;
  Stmt *stmt_2;

  CondElse(const CondElse &);
  CondElse &operator=(const CondElse &);
  CondElse(Expr *p1, Stmt *p2, Stmt *p3);
  ~CondElse();
  virtual void accept(Visitor *v);
  virtual CondElse *clone() const;
  void swap(CondElse &);
};

class While : public Stmt
{
public:
  Expr *expr_;
  Stmt *stmt_;

  While(const While &);
  While &operator=(const While &);
  While(Expr *p1, Stmt *p2);
  ~While();
  virtual void accept(Visitor *v);
  virtual While *clone() const;
  void swap(While &);
};

class SExp : public Stmt
{
public:
  Expr *expr_;

  SExp(const SExp &);
  SExp &operator=(const SExp &);
  SExp(Expr *p1);
  ~SExp();
  virtual void accept(Visitor *v);
  virtual SExp *clone() const;
  void swap(SExp &);
};

class NoInit : public Item
{
public:
  Ident ident_;

  NoInit(const NoInit &);
  NoInit &operator=(const NoInit &);
  NoInit(Ident p1);
  ~NoInit();
  virtual void accept(Visitor *v);
  virtual NoInit *clone() const;
  void swap(NoInit &);
};

class Init : public Item
{
public:
  Ident ident_;
  Expr *expr_;

  Init(const Init &);
  Init &operator=(const Init &);
  Init(Ident p1, Expr *p2);
  ~Init();
  virtual void accept(Visitor *v);
  virtual Init *clone() const;
  void swap(Init &);
};

class TInt : public Type
{
public:

  TInt(const TInt &);
  TInt &operator=(const TInt &);
  TInt();
  ~TInt();
  virtual void accept(Visitor *v);
  virtual TInt *clone() const;
  void swap(TInt &);
};

class TStr : public Type
{
public:

  TStr(const TStr &);
  TStr &operator=(const TStr &);
  TStr();
  ~TStr();
  virtual void accept(Visitor *v);
  virtual TStr *clone() const;
  void swap(TStr &);
};

class TBool : public Type
{
public:

  TBool(const TBool &);
  TBool &operator=(const TBool &);
  TBool();
  ~TBool();
  virtual void accept(Visitor *v);
  virtual TBool *clone() const;
  void swap(TBool &);
};

class TVoid : public Type
{
public:

  TVoid(const TVoid &);
  TVoid &operator=(const TVoid &);
  TVoid();
  ~TVoid();
  virtual void accept(Visitor *v);
  virtual TVoid *clone() const;
  void swap(TVoid &);
};

class EVar : public Expr
{
public:
  Ident ident_;

  EVar(const EVar &);
  EVar &operator=(const EVar &);
  EVar(Ident p1);
  ~EVar();
  virtual void accept(Visitor *v);
  virtual EVar *clone() const;
  void swap(EVar &);
};

class ELitInt : public Expr
{
public:
  Integer integer_;

  ELitInt(const ELitInt &);
  ELitInt &operator=(const ELitInt &);
  ELitInt(Integer p1);
  ~ELitInt();
  virtual void accept(Visitor *v);
  virtual ELitInt *clone() const;
  void swap(ELitInt &);
};

class ELitTrue : public Expr
{
public:

  ELitTrue(const ELitTrue &);
  ELitTrue &operator=(const ELitTrue &);
  ELitTrue();
  ~ELitTrue();
  virtual void accept(Visitor *v);
  virtual ELitTrue *clone() const;
  void swap(ELitTrue &);
};

class ELitFalse : public Expr
{
public:

  ELitFalse(const ELitFalse &);
  ELitFalse &operator=(const ELitFalse &);
  ELitFalse();
  ~ELitFalse();
  virtual void accept(Visitor *v);
  virtual ELitFalse *clone() const;
  void swap(ELitFalse &);
};

class EApp : public Expr
{
public:
  Ident ident_;
  ListExpr *listexpr_;

  EApp(const EApp &);
  EApp &operator=(const EApp &);
  EApp(Ident p1, ListExpr *p2);
  ~EApp();
  virtual void accept(Visitor *v);
  virtual EApp *clone() const;
  void swap(EApp &);
};

class EString : public Expr
{
public:
  String string_;

  EString(const EString &);
  EString &operator=(const EString &);
  EString(String p1);
  ~EString();
  virtual void accept(Visitor *v);
  virtual EString *clone() const;
  void swap(EString &);
};

class Neg : public Expr
{
public:
  Expr *expr_;

  Neg(const Neg &);
  Neg &operator=(const Neg &);
  Neg(Expr *p1);
  ~Neg();
  virtual void accept(Visitor *v);
  virtual Neg *clone() const;
  void swap(Neg &);
};

class Not : public Expr
{
public:
  Expr *expr_;

  Not(const Not &);
  Not &operator=(const Not &);
  Not(Expr *p1);
  ~Not();
  virtual void accept(Visitor *v);
  virtual Not *clone() const;
  void swap(Not &);
};

class EMul : public Expr
{
public:
  Expr *expr_1;
  MulOp *mulop_;
  Expr *expr_2;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Expr *p1, MulOp *p2, Expr *p3);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual EMul *clone() const;
  void swap(EMul &);
};

class EAdd : public Expr
{
public:
  Expr *expr_1;
  AddOp *addop_;
  Expr *expr_2;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Expr *p1, AddOp *p2, Expr *p3);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual EAdd *clone() const;
  void swap(EAdd &);
};

class ERel : public Expr
{
public:
  Expr *expr_1;
  RelOp *relop_;
  Expr *expr_2;

  ERel(const ERel &);
  ERel &operator=(const ERel &);
  ERel(Expr *p1, RelOp *p2, Expr *p3);
  ~ERel();
  virtual void accept(Visitor *v);
  virtual ERel *clone() const;
  void swap(ERel &);
};

class EAnd : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EAnd(const EAnd &);
  EAnd &operator=(const EAnd &);
  EAnd(Expr *p1, Expr *p2);
  ~EAnd();
  virtual void accept(Visitor *v);
  virtual EAnd *clone() const;
  void swap(EAnd &);
};

class EOr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EOr(const EOr &);
  EOr &operator=(const EOr &);
  EOr(Expr *p1, Expr *p2);
  ~EOr();
  virtual void accept(Visitor *v);
  virtual EOr *clone() const;
  void swap(EOr &);
};

class OpPlus : public AddOp
{
public:

  OpPlus(const OpPlus &);
  OpPlus &operator=(const OpPlus &);
  OpPlus();
  ~OpPlus();
  virtual void accept(Visitor *v);
  virtual OpPlus *clone() const;
  void swap(OpPlus &);
};

class OpMinus : public AddOp
{
public:

  OpMinus(const OpMinus &);
  OpMinus &operator=(const OpMinus &);
  OpMinus();
  ~OpMinus();
  virtual void accept(Visitor *v);
  virtual OpMinus *clone() const;
  void swap(OpMinus &);
};

class OpTimes : public MulOp
{
public:

  OpTimes(const OpTimes &);
  OpTimes &operator=(const OpTimes &);
  OpTimes();
  ~OpTimes();
  virtual void accept(Visitor *v);
  virtual OpTimes *clone() const;
  void swap(OpTimes &);
};

class OpDiv : public MulOp
{
public:

  OpDiv(const OpDiv &);
  OpDiv &operator=(const OpDiv &);
  OpDiv();
  ~OpDiv();
  virtual void accept(Visitor *v);
  virtual OpDiv *clone() const;
  void swap(OpDiv &);
};

class OpMod : public MulOp
{
public:

  OpMod(const OpMod &);
  OpMod &operator=(const OpMod &);
  OpMod();
  ~OpMod();
  virtual void accept(Visitor *v);
  virtual OpMod *clone() const;
  void swap(OpMod &);
};

class OpLTH : public RelOp
{
public:

  OpLTH(const OpLTH &);
  OpLTH &operator=(const OpLTH &);
  OpLTH();
  ~OpLTH();
  virtual void accept(Visitor *v);
  virtual OpLTH *clone() const;
  void swap(OpLTH &);
};

class OpLE : public RelOp
{
public:

  OpLE(const OpLE &);
  OpLE &operator=(const OpLE &);
  OpLE();
  ~OpLE();
  virtual void accept(Visitor *v);
  virtual OpLE *clone() const;
  void swap(OpLE &);
};

class OpGTH : public RelOp
{
public:

  OpGTH(const OpGTH &);
  OpGTH &operator=(const OpGTH &);
  OpGTH();
  ~OpGTH();
  virtual void accept(Visitor *v);
  virtual OpGTH *clone() const;
  void swap(OpGTH &);
};

class OpGE : public RelOp
{
public:

  OpGE(const OpGE &);
  OpGE &operator=(const OpGE &);
  OpGE();
  ~OpGE();
  virtual void accept(Visitor *v);
  virtual OpGE *clone() const;
  void swap(OpGE &);
};

class OpEQU : public RelOp
{
public:

  OpEQU(const OpEQU &);
  OpEQU &operator=(const OpEQU &);
  OpEQU();
  ~OpEQU();
  virtual void accept(Visitor *v);
  virtual OpEQU *clone() const;
  void swap(OpEQU &);
};

class OpNE : public RelOp
{
public:

  OpNE(const OpNE &);
  OpNE &operator=(const OpNE &);
  OpNE();
  ~OpNE();
  virtual void accept(Visitor *v);
  virtual OpNE *clone() const;
  void swap(OpNE &);
};



class ListTopDef : public Visitable, public std::vector<TopDef*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListTopDef *clone() const;
};

class ListArg : public Visitable, public std::vector<Arg*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListArg *clone() const;
};

class ListStmt : public Visitable, public std::vector<Stmt*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStmt *clone() const;
};

class ListItem : public Visitable, public std::vector<Item*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListItem *clone() const;
};

class ListExpr : public Visitable, public std::vector<Expr*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExpr *clone() const;
};



#endif
