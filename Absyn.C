//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   TProgram    ********************/
TProgram::TProgram(ListTopDef *p1)
{
  listtopdef_ = p1;

}

TProgram::TProgram(const TProgram & other)
{
  listtopdef_ = other.listtopdef_->clone();

}

TProgram &TProgram::operator=(const TProgram & other)
{
  TProgram tmp(other);
  swap(tmp);
  return *this;
}

void TProgram::swap(TProgram & other)
{
  std::swap(listtopdef_, other.listtopdef_);

}

TProgram::~TProgram()
{
  delete(listtopdef_);

}

void TProgram::accept(Visitor *v)
{
  v->visitTProgram(this);
}

TProgram *TProgram::clone() const
{
  return new TProgram(*this);
}



/********************   TFnDef    ********************/
TFnDef::TFnDef(Type *p1, Ident p2, ListArg *p3, Block *p4)
{
  type_ = p1;
  ident_ = p2;
  listarg_ = p3;
  block_ = p4;

}

TFnDef::TFnDef(const TFnDef & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  listarg_ = other.listarg_->clone();
  block_ = other.block_->clone();

}

TFnDef &TFnDef::operator=(const TFnDef & other)
{
  TFnDef tmp(other);
  swap(tmp);
  return *this;
}

void TFnDef::swap(TFnDef & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(listarg_, other.listarg_);
  std::swap(block_, other.block_);

}

TFnDef::~TFnDef()
{
  delete(type_);
  delete(listarg_);
  delete(block_);

}

void TFnDef::accept(Visitor *v)
{
  v->visitTFnDef(this);
}

TFnDef *TFnDef::clone() const
{
  return new TFnDef(*this);
}



/********************   TArg    ********************/
TArg::TArg(Type *p1, Ident p2)
{
  type_ = p1;
  ident_ = p2;

}

TArg::TArg(const TArg & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;

}

TArg &TArg::operator=(const TArg & other)
{
  TArg tmp(other);
  swap(tmp);
  return *this;
}

void TArg::swap(TArg & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

TArg::~TArg()
{
  delete(type_);

}

void TArg::accept(Visitor *v)
{
  v->visitTArg(this);
}

TArg *TArg::clone() const
{
  return new TArg(*this);
}



/********************   TBlock    ********************/
TBlock::TBlock(ListStmt *p1)
{
  liststmt_ = p1;

}

TBlock::TBlock(const TBlock & other)
{
  liststmt_ = other.liststmt_->clone();

}

TBlock &TBlock::operator=(const TBlock & other)
{
  TBlock tmp(other);
  swap(tmp);
  return *this;
}

void TBlock::swap(TBlock & other)
{
  std::swap(liststmt_, other.liststmt_);

}

TBlock::~TBlock()
{
  delete(liststmt_);

}

void TBlock::accept(Visitor *v)
{
  v->visitTBlock(this);
}

TBlock *TBlock::clone() const
{
  return new TBlock(*this);
}



/********************   Empty    ********************/
Empty::Empty()
{

}

Empty::Empty(const Empty & other)
{

}

Empty &Empty::operator=(const Empty & other)
{
  Empty tmp(other);
  swap(tmp);
  return *this;
}

void Empty::swap(Empty & other)
{

}

Empty::~Empty()
{

}

void Empty::accept(Visitor *v)
{
  v->visitEmpty(this);
}

Empty *Empty::clone() const
{
  return new Empty(*this);
}



/********************   BStmt    ********************/
BStmt::BStmt(Block *p1)
{
  block_ = p1;

}

BStmt::BStmt(const BStmt & other)
{
  block_ = other.block_->clone();

}

BStmt &BStmt::operator=(const BStmt & other)
{
  BStmt tmp(other);
  swap(tmp);
  return *this;
}

void BStmt::swap(BStmt & other)
{
  std::swap(block_, other.block_);

}

BStmt::~BStmt()
{
  delete(block_);

}

void BStmt::accept(Visitor *v)
{
  v->visitBStmt(this);
}

BStmt *BStmt::clone() const
{
  return new BStmt(*this);
}



/********************   Decl    ********************/
Decl::Decl(Type *p1, ListItem *p2)
{
  type_ = p1;
  listitem_ = p2;

}

Decl::Decl(const Decl & other)
{
  type_ = other.type_->clone();
  listitem_ = other.listitem_->clone();

}

Decl &Decl::operator=(const Decl & other)
{
  Decl tmp(other);
  swap(tmp);
  return *this;
}

void Decl::swap(Decl & other)
{
  std::swap(type_, other.type_);
  std::swap(listitem_, other.listitem_);

}

Decl::~Decl()
{
  delete(type_);
  delete(listitem_);

}

void Decl::accept(Visitor *v)
{
  v->visitDecl(this);
}

Decl *Decl::clone() const
{
  return new Decl(*this);
}



/********************   Ass    ********************/
Ass::Ass(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

Ass::Ass(const Ass & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

Ass &Ass::operator=(const Ass & other)
{
  Ass tmp(other);
  swap(tmp);
  return *this;
}

void Ass::swap(Ass & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

Ass::~Ass()
{
  delete(expr_);

}

void Ass::accept(Visitor *v)
{
  v->visitAss(this);
}

Ass *Ass::clone() const
{
  return new Ass(*this);
}



/********************   Incr    ********************/
Incr::Incr(Ident p1)
{
  ident_ = p1;

}

Incr::Incr(const Incr & other)
{
  ident_ = other.ident_;

}

Incr &Incr::operator=(const Incr & other)
{
  Incr tmp(other);
  swap(tmp);
  return *this;
}

void Incr::swap(Incr & other)
{
  std::swap(ident_, other.ident_);

}

Incr::~Incr()
{

}

void Incr::accept(Visitor *v)
{
  v->visitIncr(this);
}

Incr *Incr::clone() const
{
  return new Incr(*this);
}



/********************   Decr    ********************/
Decr::Decr(Ident p1)
{
  ident_ = p1;

}

Decr::Decr(const Decr & other)
{
  ident_ = other.ident_;

}

Decr &Decr::operator=(const Decr & other)
{
  Decr tmp(other);
  swap(tmp);
  return *this;
}

void Decr::swap(Decr & other)
{
  std::swap(ident_, other.ident_);

}

Decr::~Decr()
{

}

void Decr::accept(Visitor *v)
{
  v->visitDecr(this);
}

Decr *Decr::clone() const
{
  return new Decr(*this);
}



/********************   Ret    ********************/
Ret::Ret(Expr *p1)
{
  expr_ = p1;

}

Ret::Ret(const Ret & other)
{
  expr_ = other.expr_->clone();

}

Ret &Ret::operator=(const Ret & other)
{
  Ret tmp(other);
  swap(tmp);
  return *this;
}

void Ret::swap(Ret & other)
{
  std::swap(expr_, other.expr_);

}

Ret::~Ret()
{
  delete(expr_);

}

void Ret::accept(Visitor *v)
{
  v->visitRet(this);
}

Ret *Ret::clone() const
{
  return new Ret(*this);
}



/********************   VRet    ********************/
VRet::VRet()
{

}

VRet::VRet(const VRet & other)
{

}

VRet &VRet::operator=(const VRet & other)
{
  VRet tmp(other);
  swap(tmp);
  return *this;
}

void VRet::swap(VRet & other)
{

}

VRet::~VRet()
{

}

void VRet::accept(Visitor *v)
{
  v->visitVRet(this);
}

VRet *VRet::clone() const
{
  return new VRet(*this);
}



/********************   Cond    ********************/
Cond::Cond(Expr *p1, Stmt *p2)
{
  expr_ = p1;
  stmt_ = p2;

}

Cond::Cond(const Cond & other)
{
  expr_ = other.expr_->clone();
  stmt_ = other.stmt_->clone();

}

Cond &Cond::operator=(const Cond & other)
{
  Cond tmp(other);
  swap(tmp);
  return *this;
}

void Cond::swap(Cond & other)
{
  std::swap(expr_, other.expr_);
  std::swap(stmt_, other.stmt_);

}

Cond::~Cond()
{
  delete(expr_);
  delete(stmt_);

}

void Cond::accept(Visitor *v)
{
  v->visitCond(this);
}

Cond *Cond::clone() const
{
  return new Cond(*this);
}



/********************   CondElse    ********************/
CondElse::CondElse(Expr *p1, Stmt *p2, Stmt *p3)
{
  expr_ = p1;
  stmt_1 = p2;
  stmt_2 = p3;

}

CondElse::CondElse(const CondElse & other)
{
  expr_ = other.expr_->clone();
  stmt_1 = other.stmt_1->clone();
  stmt_2 = other.stmt_2->clone();

}

CondElse &CondElse::operator=(const CondElse & other)
{
  CondElse tmp(other);
  swap(tmp);
  return *this;
}

void CondElse::swap(CondElse & other)
{
  std::swap(expr_, other.expr_);
  std::swap(stmt_1, other.stmt_1);
  std::swap(stmt_2, other.stmt_2);

}

CondElse::~CondElse()
{
  delete(expr_);
  delete(stmt_1);
  delete(stmt_2);

}

void CondElse::accept(Visitor *v)
{
  v->visitCondElse(this);
}

CondElse *CondElse::clone() const
{
  return new CondElse(*this);
}



/********************   While    ********************/
While::While(Expr *p1, Stmt *p2)
{
  expr_ = p1;
  stmt_ = p2;

}

While::While(const While & other)
{
  expr_ = other.expr_->clone();
  stmt_ = other.stmt_->clone();

}

While &While::operator=(const While & other)
{
  While tmp(other);
  swap(tmp);
  return *this;
}

void While::swap(While & other)
{
  std::swap(expr_, other.expr_);
  std::swap(stmt_, other.stmt_);

}

While::~While()
{
  delete(expr_);
  delete(stmt_);

}

void While::accept(Visitor *v)
{
  v->visitWhile(this);
}

While *While::clone() const
{
  return new While(*this);
}



/********************   SExp    ********************/
SExp::SExp(Expr *p1)
{
  expr_ = p1;

}

SExp::SExp(const SExp & other)
{
  expr_ = other.expr_->clone();

}

SExp &SExp::operator=(const SExp & other)
{
  SExp tmp(other);
  swap(tmp);
  return *this;
}

void SExp::swap(SExp & other)
{
  std::swap(expr_, other.expr_);

}

SExp::~SExp()
{
  delete(expr_);

}

void SExp::accept(Visitor *v)
{
  v->visitSExp(this);
}

SExp *SExp::clone() const
{
  return new SExp(*this);
}



/********************   NoInit    ********************/
NoInit::NoInit(Ident p1)
{
  ident_ = p1;

}

NoInit::NoInit(const NoInit & other)
{
  ident_ = other.ident_;

}

NoInit &NoInit::operator=(const NoInit & other)
{
  NoInit tmp(other);
  swap(tmp);
  return *this;
}

void NoInit::swap(NoInit & other)
{
  std::swap(ident_, other.ident_);

}

NoInit::~NoInit()
{

}

void NoInit::accept(Visitor *v)
{
  v->visitNoInit(this);
}

NoInit *NoInit::clone() const
{
  return new NoInit(*this);
}



/********************   Init    ********************/
Init::Init(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

Init::Init(const Init & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

Init &Init::operator=(const Init & other)
{
  Init tmp(other);
  swap(tmp);
  return *this;
}

void Init::swap(Init & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

Init::~Init()
{
  delete(expr_);

}

void Init::accept(Visitor *v)
{
  v->visitInit(this);
}

Init *Init::clone() const
{
  return new Init(*this);
}



/********************   TInt    ********************/
TInt::TInt()
{

}

TInt::TInt(const TInt & other)
{

}

TInt &TInt::operator=(const TInt & other)
{
  TInt tmp(other);
  swap(tmp);
  return *this;
}

void TInt::swap(TInt & other)
{

}

TInt::~TInt()
{

}

void TInt::accept(Visitor *v)
{
  v->visitTInt(this);
}

TInt *TInt::clone() const
{
  return new TInt(*this);
}



/********************   TStr    ********************/
TStr::TStr()
{

}

TStr::TStr(const TStr & other)
{

}

TStr &TStr::operator=(const TStr & other)
{
  TStr tmp(other);
  swap(tmp);
  return *this;
}

void TStr::swap(TStr & other)
{

}

TStr::~TStr()
{

}

void TStr::accept(Visitor *v)
{
  v->visitTStr(this);
}

TStr *TStr::clone() const
{
  return new TStr(*this);
}



/********************   TBool    ********************/
TBool::TBool()
{

}

TBool::TBool(const TBool & other)
{

}

TBool &TBool::operator=(const TBool & other)
{
  TBool tmp(other);
  swap(tmp);
  return *this;
}

void TBool::swap(TBool & other)
{

}

TBool::~TBool()
{

}

void TBool::accept(Visitor *v)
{
  v->visitTBool(this);
}

TBool *TBool::clone() const
{
  return new TBool(*this);
}



/********************   TVoid    ********************/
TVoid::TVoid()
{

}

TVoid::TVoid(const TVoid & other)
{

}

TVoid &TVoid::operator=(const TVoid & other)
{
  TVoid tmp(other);
  swap(tmp);
  return *this;
}

void TVoid::swap(TVoid & other)
{

}

TVoid::~TVoid()
{

}

void TVoid::accept(Visitor *v)
{
  v->visitTVoid(this);
}

TVoid *TVoid::clone() const
{
  return new TVoid(*this);
}



/********************   EVar    ********************/
EVar::EVar(Ident p1)
{
  ident_ = p1;

}

EVar::EVar(const EVar & other)
{
  ident_ = other.ident_;

}

EVar &EVar::operator=(const EVar & other)
{
  EVar tmp(other);
  swap(tmp);
  return *this;
}

void EVar::swap(EVar & other)
{
  std::swap(ident_, other.ident_);

}

EVar::~EVar()
{

}

void EVar::accept(Visitor *v)
{
  v->visitEVar(this);
}

EVar *EVar::clone() const
{
  return new EVar(*this);
}



/********************   ELitInt    ********************/
ELitInt::ELitInt(Integer p1)
{
  integer_ = p1;

}

ELitInt::ELitInt(const ELitInt & other)
{
  integer_ = other.integer_;

}

ELitInt &ELitInt::operator=(const ELitInt & other)
{
  ELitInt tmp(other);
  swap(tmp);
  return *this;
}

void ELitInt::swap(ELitInt & other)
{
  std::swap(integer_, other.integer_);

}

ELitInt::~ELitInt()
{

}

void ELitInt::accept(Visitor *v)
{
  v->visitELitInt(this);
}

ELitInt *ELitInt::clone() const
{
  return new ELitInt(*this);
}



/********************   ELitTrue    ********************/
ELitTrue::ELitTrue()
{

}

ELitTrue::ELitTrue(const ELitTrue & other)
{

}

ELitTrue &ELitTrue::operator=(const ELitTrue & other)
{
  ELitTrue tmp(other);
  swap(tmp);
  return *this;
}

void ELitTrue::swap(ELitTrue & other)
{

}

ELitTrue::~ELitTrue()
{

}

void ELitTrue::accept(Visitor *v)
{
  v->visitELitTrue(this);
}

ELitTrue *ELitTrue::clone() const
{
  return new ELitTrue(*this);
}



/********************   ELitFalse    ********************/
ELitFalse::ELitFalse()
{

}

ELitFalse::ELitFalse(const ELitFalse & other)
{

}

ELitFalse &ELitFalse::operator=(const ELitFalse & other)
{
  ELitFalse tmp(other);
  swap(tmp);
  return *this;
}

void ELitFalse::swap(ELitFalse & other)
{

}

ELitFalse::~ELitFalse()
{

}

void ELitFalse::accept(Visitor *v)
{
  v->visitELitFalse(this);
}

ELitFalse *ELitFalse::clone() const
{
  return new ELitFalse(*this);
}



/********************   EApp    ********************/
EApp::EApp(Ident p1, ListExpr *p2)
{
  ident_ = p1;
  listexpr_ = p2;

}

EApp::EApp(const EApp & other)
{
  ident_ = other.ident_;
  listexpr_ = other.listexpr_->clone();

}

EApp &EApp::operator=(const EApp & other)
{
  EApp tmp(other);
  swap(tmp);
  return *this;
}

void EApp::swap(EApp & other)
{
  std::swap(ident_, other.ident_);
  std::swap(listexpr_, other.listexpr_);

}

EApp::~EApp()
{
  delete(listexpr_);

}

void EApp::accept(Visitor *v)
{
  v->visitEApp(this);
}

EApp *EApp::clone() const
{
  return new EApp(*this);
}



/********************   EString    ********************/
EString::EString(String p1)
{
  string_ = p1;

}

EString::EString(const EString & other)
{
  string_ = other.string_;

}

EString &EString::operator=(const EString & other)
{
  EString tmp(other);
  swap(tmp);
  return *this;
}

void EString::swap(EString & other)
{
  std::swap(string_, other.string_);

}

EString::~EString()
{

}

void EString::accept(Visitor *v)
{
  v->visitEString(this);
}

EString *EString::clone() const
{
  return new EString(*this);
}



/********************   Neg    ********************/
Neg::Neg(Expr *p1)
{
  expr_ = p1;

}

Neg::Neg(const Neg & other)
{
  expr_ = other.expr_->clone();

}

Neg &Neg::operator=(const Neg & other)
{
  Neg tmp(other);
  swap(tmp);
  return *this;
}

void Neg::swap(Neg & other)
{
  std::swap(expr_, other.expr_);

}

Neg::~Neg()
{
  delete(expr_);

}

void Neg::accept(Visitor *v)
{
  v->visitNeg(this);
}

Neg *Neg::clone() const
{
  return new Neg(*this);
}



/********************   Not    ********************/
Not::Not(Expr *p1)
{
  expr_ = p1;

}

Not::Not(const Not & other)
{
  expr_ = other.expr_->clone();

}

Not &Not::operator=(const Not & other)
{
  Not tmp(other);
  swap(tmp);
  return *this;
}

void Not::swap(Not & other)
{
  std::swap(expr_, other.expr_);

}

Not::~Not()
{
  delete(expr_);

}

void Not::accept(Visitor *v)
{
  v->visitNot(this);
}

Not *Not::clone() const
{
  return new Not(*this);
}



/********************   EMul    ********************/
EMul::EMul(Expr *p1, MulOp *p2, Expr *p3)
{
  expr_1 = p1;
  mulop_ = p2;
  expr_2 = p3;

}

EMul::EMul(const EMul & other)
{
  expr_1 = other.expr_1->clone();
  mulop_ = other.mulop_->clone();
  expr_2 = other.expr_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(mulop_, other.mulop_);
  std::swap(expr_2, other.expr_2);

}

EMul::~EMul()
{
  delete(expr_1);
  delete(mulop_);
  delete(expr_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Expr *p1, AddOp *p2, Expr *p3)
{
  expr_1 = p1;
  addop_ = p2;
  expr_2 = p3;

}

EAdd::EAdd(const EAdd & other)
{
  expr_1 = other.expr_1->clone();
  addop_ = other.addop_->clone();
  expr_2 = other.expr_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(addop_, other.addop_);
  std::swap(expr_2, other.expr_2);

}

EAdd::~EAdd()
{
  delete(expr_1);
  delete(addop_);
  delete(expr_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ERel    ********************/
ERel::ERel(Expr *p1, RelOp *p2, Expr *p3)
{
  expr_1 = p1;
  relop_ = p2;
  expr_2 = p3;

}

ERel::ERel(const ERel & other)
{
  expr_1 = other.expr_1->clone();
  relop_ = other.relop_->clone();
  expr_2 = other.expr_2->clone();

}

ERel &ERel::operator=(const ERel & other)
{
  ERel tmp(other);
  swap(tmp);
  return *this;
}

void ERel::swap(ERel & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(relop_, other.relop_);
  std::swap(expr_2, other.expr_2);

}

ERel::~ERel()
{
  delete(expr_1);
  delete(relop_);
  delete(expr_2);

}

void ERel::accept(Visitor *v)
{
  v->visitERel(this);
}

ERel *ERel::clone() const
{
  return new ERel(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EAnd::~EAnd()
{
  delete(expr_1);
  delete(expr_2);

}

void EAnd::accept(Visitor *v)
{
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EOr    ********************/
EOr::EOr(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EOr::EOr(const EOr & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EOr::~EOr()
{
  delete(expr_1);
  delete(expr_2);

}

void EOr::accept(Visitor *v)
{
  v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   OpPlus    ********************/
OpPlus::OpPlus()
{

}

OpPlus::OpPlus(const OpPlus & other)
{

}

OpPlus &OpPlus::operator=(const OpPlus & other)
{
  OpPlus tmp(other);
  swap(tmp);
  return *this;
}

void OpPlus::swap(OpPlus & other)
{

}

OpPlus::~OpPlus()
{

}

void OpPlus::accept(Visitor *v)
{
  v->visitOpPlus(this);
}

OpPlus *OpPlus::clone() const
{
  return new OpPlus(*this);
}



/********************   OpMinus    ********************/
OpMinus::OpMinus()
{

}

OpMinus::OpMinus(const OpMinus & other)
{

}

OpMinus &OpMinus::operator=(const OpMinus & other)
{
  OpMinus tmp(other);
  swap(tmp);
  return *this;
}

void OpMinus::swap(OpMinus & other)
{

}

OpMinus::~OpMinus()
{

}

void OpMinus::accept(Visitor *v)
{
  v->visitOpMinus(this);
}

OpMinus *OpMinus::clone() const
{
  return new OpMinus(*this);
}



/********************   OpTimes    ********************/
OpTimes::OpTimes()
{

}

OpTimes::OpTimes(const OpTimes & other)
{

}

OpTimes &OpTimes::operator=(const OpTimes & other)
{
  OpTimes tmp(other);
  swap(tmp);
  return *this;
}

void OpTimes::swap(OpTimes & other)
{

}

OpTimes::~OpTimes()
{

}

void OpTimes::accept(Visitor *v)
{
  v->visitOpTimes(this);
}

OpTimes *OpTimes::clone() const
{
  return new OpTimes(*this);
}



/********************   OpDiv    ********************/
OpDiv::OpDiv()
{

}

OpDiv::OpDiv(const OpDiv & other)
{

}

OpDiv &OpDiv::operator=(const OpDiv & other)
{
  OpDiv tmp(other);
  swap(tmp);
  return *this;
}

void OpDiv::swap(OpDiv & other)
{

}

OpDiv::~OpDiv()
{

}

void OpDiv::accept(Visitor *v)
{
  v->visitOpDiv(this);
}

OpDiv *OpDiv::clone() const
{
  return new OpDiv(*this);
}



/********************   OpMod    ********************/
OpMod::OpMod()
{

}

OpMod::OpMod(const OpMod & other)
{

}

OpMod &OpMod::operator=(const OpMod & other)
{
  OpMod tmp(other);
  swap(tmp);
  return *this;
}

void OpMod::swap(OpMod & other)
{

}

OpMod::~OpMod()
{

}

void OpMod::accept(Visitor *v)
{
  v->visitOpMod(this);
}

OpMod *OpMod::clone() const
{
  return new OpMod(*this);
}



/********************   OpLTH    ********************/
OpLTH::OpLTH()
{

}

OpLTH::OpLTH(const OpLTH & other)
{

}

OpLTH &OpLTH::operator=(const OpLTH & other)
{
  OpLTH tmp(other);
  swap(tmp);
  return *this;
}

void OpLTH::swap(OpLTH & other)
{

}

OpLTH::~OpLTH()
{

}

void OpLTH::accept(Visitor *v)
{
  v->visitOpLTH(this);
}

OpLTH *OpLTH::clone() const
{
  return new OpLTH(*this);
}



/********************   OpLE    ********************/
OpLE::OpLE()
{

}

OpLE::OpLE(const OpLE & other)
{

}

OpLE &OpLE::operator=(const OpLE & other)
{
  OpLE tmp(other);
  swap(tmp);
  return *this;
}

void OpLE::swap(OpLE & other)
{

}

OpLE::~OpLE()
{

}

void OpLE::accept(Visitor *v)
{
  v->visitOpLE(this);
}

OpLE *OpLE::clone() const
{
  return new OpLE(*this);
}



/********************   OpGTH    ********************/
OpGTH::OpGTH()
{

}

OpGTH::OpGTH(const OpGTH & other)
{

}

OpGTH &OpGTH::operator=(const OpGTH & other)
{
  OpGTH tmp(other);
  swap(tmp);
  return *this;
}

void OpGTH::swap(OpGTH & other)
{

}

OpGTH::~OpGTH()
{

}

void OpGTH::accept(Visitor *v)
{
  v->visitOpGTH(this);
}

OpGTH *OpGTH::clone() const
{
  return new OpGTH(*this);
}



/********************   OpGE    ********************/
OpGE::OpGE()
{

}

OpGE::OpGE(const OpGE & other)
{

}

OpGE &OpGE::operator=(const OpGE & other)
{
  OpGE tmp(other);
  swap(tmp);
  return *this;
}

void OpGE::swap(OpGE & other)
{

}

OpGE::~OpGE()
{

}

void OpGE::accept(Visitor *v)
{
  v->visitOpGE(this);
}

OpGE *OpGE::clone() const
{
  return new OpGE(*this);
}



/********************   OpEQU    ********************/
OpEQU::OpEQU()
{

}

OpEQU::OpEQU(const OpEQU & other)
{

}

OpEQU &OpEQU::operator=(const OpEQU & other)
{
  OpEQU tmp(other);
  swap(tmp);
  return *this;
}

void OpEQU::swap(OpEQU & other)
{

}

OpEQU::~OpEQU()
{

}

void OpEQU::accept(Visitor *v)
{
  v->visitOpEQU(this);
}

OpEQU *OpEQU::clone() const
{
  return new OpEQU(*this);
}



/********************   OpNE    ********************/
OpNE::OpNE()
{

}

OpNE::OpNE(const OpNE & other)
{

}

OpNE &OpNE::operator=(const OpNE & other)
{
  OpNE tmp(other);
  swap(tmp);
  return *this;
}

void OpNE::swap(OpNE & other)
{

}

OpNE::~OpNE()
{

}

void OpNE::accept(Visitor *v)
{
  v->visitOpNE(this);
}

OpNE *OpNE::clone() const
{
  return new OpNE(*this);
}




/********************   ListTopDef    ********************/

void ListTopDef::accept(Visitor *v)
{
  v->visitListTopDef(this);
}


ListTopDef *ListTopDef::clone() const
{
  return new ListTopDef(*this);
}


/********************   ListArg    ********************/

void ListArg::accept(Visitor *v)
{
  v->visitListArg(this);
}


ListArg *ListArg::clone() const
{
  return new ListArg(*this);
}


/********************   ListStmt    ********************/

void ListStmt::accept(Visitor *v)
{
  v->visitListStmt(this);
}


ListStmt *ListStmt::clone() const
{
  return new ListStmt(*this);
}


/********************   ListItem    ********************/

void ListItem::accept(Visitor *v)
{
  v->visitListItem(this);
}


ListItem *ListItem::clone() const
{
  return new ListItem(*this);
}


/********************   ListExpr    ********************/

void ListExpr::accept(Visitor *v)
{
  v->visitListExpr(this);
}


ListExpr *ListExpr::clone() const
{
  return new ListExpr(*this);
}




